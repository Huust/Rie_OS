# 系统调用
系统调用是出于安全性的角度：OS对用户进程极其不放心，但为了提高用户进程的执行力（处理各种任务，减少对用户进程的约束），OS为用户提供了一组借接口，即系统调用
`balance(computer_security, process_flexibility) -> syscall`

## 实现的基本原理
- 模仿linux的`syscall()`，传入参数为子功能号+你需要传递给系统调用的参数
- 但是我们要使用的是`_syscall()`，该函数已被linux舍弃，因为**它支持可变参数数量有限（最多7个），并且还需要传入每一个参数的类型，较为复杂；此外该函数存在安全漏洞**

## 系统调用实现框架
- 1.设计宏函数_syscall，该函数由用户进程调用，函数的核心代码是**将子功能号传入eax，执行int 0x80中断**
- 2.因为第一步中执行int 0x80软件中断，**所以要在idt中先存入0x80位置的中断入口函数**
- 3.中断入口函数将子功能号传入，通过子功能号做索引偏移，找到实际执行具体系统调用的那个函数的入口
- 4.具体实现的那个函数是属于内核态的
>以某个process调用get_pid为例：`get_pid()`-->`syscall()`-->`mov eax, 子功能号; int 0x80`-->**进入int 0x80的入口函数**-->**通过索引（比如一个函数指针数组）找到具体的实现函数`sys_getpid()`**-->返回pid

>1.`get_pid()`加上前缀`sys_`代表这是处在内核态的具体实现的函数，而`get_pid()`只是用户态调用的第一层函数
>2.`int 0x80`是软中断。首先，int是x86原生支持的汇编指令，该指令执行后将去idt中找到int后面数值所对应的中断入口函数并且执行；软中断可以自己触发，而硬件中断是硬件达到某个状态时，首先通知8259A，再由8259A通知CPU去执行对应位置的中断函数。
